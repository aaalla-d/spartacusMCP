/*
 * SPDX-FileCopyrightText: 2025 SAP Spartacus team <spartacus-team@sap.com>
 *
 * SPDX-License-Identifier: Apache-2.0
 * 
 * NOTE: This is an example component generated by Spartacus MCP Server
 * To use this component, ensure you have Angular and Spartacus dependencies installed
 */

import { Product, ProductGridConfig } from './models/product-grid.model';
import { ProductGridService } from './product-grid.service';

/**
 * Product Grid Component
 * 
 * A responsive product grid component that displays products in a grid layout
 * with customizable columns, filtering, and sorting capabilities.
 * 
 * @example
 * ```html
 * <cx-product-grid
 *   [products]="products"
 *   [columns]="4"
 *   [showPrices]="true"
 *   [showRatings]="true"
 *   [title]="'Featured Products'">
 * </cx-product-grid>
 * ```
 */
export class ProductGridComponent {
  // Component metadata (would be handled by @Component decorator)
  static readonly componentConfig = {
    selector: 'cx-product-grid',
    templateUrl: './product-grid.component.html',
    styleUrls: ['./product-grid.component.scss'],
    changeDetection: 'OnPush'
  };

  // Component inputs (would be handled by @Input decorators)
  products: Product[] = [];
  columns = 4;
  showPrices = true;
  showRatings = true;
  showAddToCart = true;
  title = 'Featured Products';
  maxItems = 12;
  responsive = true;
  accessibility = true;
  config: ProductGridConfig = {};

  // Internal state
  private isDestroyed = false;
  private isLoading = false;
  private currentPage = 1;
  private itemsPerPage = 12;

  // Public observables for template
  get products$() {
    return {
      subscribe: (observer: any) => observer(this.products),
      pipe: (...operators: any[]) => this.products$
    };
  }

  get loading$() {
    return {
      subscribe: (observer: any) => observer(this.isLoading),
      pipe: (...operators: any[]) => this.loading$
    };
  }

  // Computed properties
  get displayedProducts(): Product[] {
    const startIndex = (this.currentPage - 1) * this.itemsPerPage;
    const endIndex = startIndex + this.itemsPerPage;
    return this.products.slice(startIndex, endIndex);
  }

  get totalPages(): number {
    return Math.ceil(this.products.length / this.itemsPerPage);
  }

  get gridClasses(): string[] {
    const classes = ['cx-product-grid'];
    
    if (this.responsive) classes.push('cx-product-grid--responsive');
    classes.push(`cx-product-grid--columns-${this.columns}`);
    
    return classes;
  }

  constructor(private readonly productGridService: ProductGridService) {
    // Component initialization
  }

  ngOnInit(): void {
    this.initializeConfiguration();
    this.loadProducts();
    
    if (this.accessibility) {
      this.setupAccessibilityFeatures();
    }
  }

  ngOnDestroy(): void {
    this.isDestroyed = true;
  }

  // Event handlers
  onAddToCart(product: Product): void {
    try {
      this.productGridService.addToCart(product);
      this.trackEvent('add_to_cart', product);
    } catch (error) {
      console.error('Error adding product to cart:', error);
    }
  }

  onProductClick(product: Product): void {
    try {
      this.productGridService.navigateToProduct(product.id);
      this.trackEvent('product_click', product);
    } catch (error) {
      console.error('Error navigating to product:', error);
    }
  }

  onPageChange(page: number): void {
    if (page >= 1 && page <= this.totalPages) {
      this.currentPage = page;
      this.trackEvent('page_change', { page, totalPages: this.totalPages });
    }
  }

  onSortChange(sortBy: string): void {
    try {
      this.products = this.productGridService.sortProducts(this.products, sortBy);
      this.trackEvent('sort_change', { sortBy });
    } catch (error) {
      console.error('Error sorting products:', error);
    }
  }

  onFilterChange(filters: { [key: string]: any }): void {
    try {
      this.loadProducts(filters);
      this.trackEvent('filter_change', filters);
    } catch (error) {
      console.error('Error filtering products:', error);
    }
  }

  // Private methods
  private initializeConfiguration(): void {
    try {
      // Merge default config with component config
      const mergedConfig = this.productGridService.mergeConfiguration(this.config);
      this.applyConfiguration(mergedConfig);
    } catch (error) {
      console.error('Error initializing product grid configuration:', error);
    }
  }

  private applyConfiguration(config: ProductGridConfig): void {
    // Apply configuration values to component properties
    Object.entries(config).forEach(([key, value]) => {
      if (value !== undefined && this.hasOwnProperty(key)) {
        (this as any)[key] = value;
      }
    });
  }

  private loadProducts(filters?: { [key: string]: any }): void {
    this.isLoading = true;
    
    try {
      // Mock loading products
      setTimeout(() => {
        if (!this.isDestroyed) {
          this.products = this.productGridService.getProducts(this.maxItems, filters);
          this.isLoading = false;
        }
      }, 500);
    } catch (error) {
      console.error('Error loading products:', error);
      this.isLoading = false;
    }
  }

  private setupAccessibilityFeatures(): void {
    // Setup keyboard navigation and ARIA attributes
    if (typeof document !== 'undefined') {
      const gridElement = document.querySelector('.cx-product-grid');
      if (gridElement) {
        gridElement.setAttribute('role', 'grid');
        gridElement.setAttribute('aria-label', this.title || 'Product grid');
      }
    }
  }

  private trackEvent(eventName: string, data: any): void {
    try {
      console.log(`Product Grid Event: ${eventName}`, {
        ...data,
        timestamp: new Date().toISOString(),
        component: 'ProductGridComponent'
      });
      
      // Example: Send to analytics service
      // this.analyticsService.track(eventName, data);
    } catch (error) {
      console.error('Error tracking event:', error);
    }
  }

  // Utility methods for template
  trackByProductId(index: number, product: Product): string {
    return product.id;
  }

  getGridClassString(): string {
    return this.gridClasses.join(' ');
  }

  hasProducts(): boolean {
    return this.products && this.products.length > 0;
  }

  isProductInStock(product: Product): boolean {
    return product.stock > 0;
  }

  formatPrice(price: number, currency = 'USD'): string {
    try {
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency
      }).format(price);
    } catch (error) {
      return `$${price.toFixed(2)}`;
    }
  }

  getProductImageUrl(product: Product, size = 'medium'): string {
    if (!product.imageUrl) return '/assets/placeholder-product.jpg';
    
    // Example image optimization
    const sizeMap: { [key: string]: string } = {
      'small': '200w',
      'medium': '400w',
      'large': '800w'
    };
    
    const imageSize = sizeMap[size] || '400w';
    return product.imageUrl.includes('?')
      ? `${product.imageUrl}&w=${imageSize}&q=80&f=webp`
      : `${product.imageUrl}?w=${imageSize}&q=80&f=webp`;
  }

  // Pagination helpers
  getPaginationPages(): number[] {
    const pages: number[] = [];
    const maxVisiblePages = 5;
    const startPage = Math.max(1, this.currentPage - Math.floor(maxVisiblePages / 2));
    const endPage = Math.min(this.totalPages, startPage + maxVisiblePages - 1);
    
    for (let i = startPage; i <= endPage; i++) {
      pages.push(i);
    }
    
    return pages;
  }

  canGoToPreviousPage(): boolean {
    return this.currentPage > 1;
  }

  canGoToNextPage(): boolean {
    return this.currentPage < this.totalPages;
  }
} 